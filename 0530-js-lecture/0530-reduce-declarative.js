// ?선언형 프로그래밍 vs. 절차형 프로그래밍
// ?declarative(선언형)
// ?procedural(절차형)

// *.reduce(): reducer 함수를 사용하는 메서드 -> 누산기, 현재 값, 현재 인덱스, 원본 배열을 인자로 가진다

// todo: psuedo1. 숫자가 몇개든 모두 더해주는 기계를 만든다
// todo: psuedo2. 웹 서비스에서 필요한 모든 숫자를 누산(accumulration)하는 과정이 많음
// ?.reduce() 배열 메서드를 사용하면 간단한 처리가 가능, 그러나 배열인지, 배열의 원소들이 숫자인지 여부를 검사하는 과정의 함수를 추가

// *declarative programming: 선언형 프로그래밍
// ?덧셈을 만들어주는 함수가 아닐까?
// ?...args: 배열의 모든 인자들을 가리킴
function sumMaker(...args) {
  // ?만약 배열이 배열이고 배열의 원소가 맞다면
  if (Array.isArray(args)) {

    // ?numberDatas라는 변수는 배열의 원소 중 타입이 number에 부합하는 조건의 원소만 새로운 배열로 리턴해준다
    // ?numberDatas는 결국 숫자인 원소만을 가진 배열이 대입되는 것이다
    let numberDatas = args.filter(elem => typeof elem === 'number');
    console.log(numberDatas);

    // *.reduce(): reducer 함수를 사용하는 메서드 -> 누산기, 현재 값, 현재 인덱스, 원본 배열을 인자로 가진다
    // ?리턴값으로 배열인 numberDatas에 .reduce() 메서드를 사용

    /* 
    *누산을 이해하기 위한 검색 결과
    ?https://terms.naver.com/entry.naver?docId=1078047&cid=40942&categoryId=32832
    
    ?누산(accumulator): 컴퓨터의 중앙처리장치에서 더하기, 빼기, 곱하기, 나누기 등의 연산을 한 결과 등을 일시적으로 저장해 두는 레지스터
    ?주로 플립플롭을 많이 연결한 형태를 하고 있다
    ?원래 누산기는 가산회로(덧셈을 해주는 회로)를 가진 레지스터(소량의 데이터 혹은 중간 처리 결과를 일시적으로 기억해주는 장치)에 대해 주어진 명칭

    ?누산기: 일반적으로는 여러 기능을 가진 레지스터와 가산기나 배수회로(곱셈, 배수가 되는 회로)가 접속돼 최종결과를 기억하는 레지스터를 의미
    ?컴퓨터의 명령도 ‘누산기의 내용에 기억장치 몇 번지의 내용을 더하라’, ‘곱셈 레지스터의 내용과 기억장치의 몇 번지 내용을 곱하고, 결과를 누산기에 기억하라’ 등의 형식을 취하는 경우가 많다고 한다

    ?레지스터의 회로는 주로 플립플롭을 많이 연결한 형태
    ?가산기나 배수회로 등의 연산장치는 논리곱(AND)·논리합(OR)·논리부정(NOT), 지연회로(dela circuit, 지연시켜서 꺼내도록 하는 것) 등의 소자를 많이 사용
    
    ?레지스터(registor): 극히 소량의 데이터나 처리중인 중간 결과를 일시적으로 기억해 두는 고속의 전용 영역
    
    ?플립플롭: 컴퓨터는 저장 기능도 지녀야 하는데, 1비트의 정보를 저장하는 회로를 플립플롭(flip-flop)이라 한다,
    ?1 또는 0과 같이 하나의 입력에 대하여 항상 그에 대응하는 출력을 발생하게 하고, 다음에 새로운 입력이 주어질 때까지 그 상태를 안정적으로 유지하는 회로
     */

    // *.reduce(): reducer 함수를 사용하는 메서드 -> 누산기, 현재 값, 현재 인덱스, 원본 배열을 인자로 가진다
    // * prev: 현재까지 누적된 값 / cur: current value, 현재값 / 초기값을 설정해준 부분: 0이 들어간 자리, 이곳에 아무것도 들어가지 않는다면 배열의 첫번째 요소값이 오게 된다
    return numberDatas.reduce((prev, cur) => prev + cur);
    // * === return numberDatas.reduce((prev, cur) => {return prev + cur}, 0);
  }
}
console.log(sumMaker(1, 2, 3, 4, 5, 6, 7, "hi"));
console.clear();



